Для решения задачи будем считать, что мы имеем дело с системой, UML диаграмма которой разработана мной в другой задаче - [domain.png](domain.png)

Поэтому для нас любой поиск пользователя по полу, городу проживания или их комбинации всегда будет связана с join таблиц, так как данные хранятся в разных таблицах. Например, будут выполнятся вот такие или подобные им запросы:

```
select p.surname, s.name from users_scheme.profile p join users_scheme.sex s on p.sex_id = s.id where p.sex="male";

select p.surname, c.name from users_scheme.profile p join users_scheme.city c on p.city_id = c.id where p.city="Moscow";

select p.surname, s.name, c.name from users_scheme.profile p join users_scheme.sex s on p.sex_id = s.id join users_scheme.city c on p.city_id = c.id where s.name="male" and c.name="Moscow";
```

В более сложных случаях поиска все равно запросы будут включать в себя подзапросы, очень похожие на них, то есть обязательно будет присутствовать в каком-то месте вложенная выборка либо по полу, городу, полу+городу пользователя (поля name соответствующих таблиц - sex или city). 

Однако, при такой схеме есть сложность при составлении составного индекса - например, индекса по названию города + названию пола. Оба этих значения хранятся в разных таблицах - users_scheme.sex поле name и users_scheme.city поле name. Поэтому, строго говоря, мы не можем напрямую создать индекс по join-у таблиц sex и city, документация Postgresql (да и других БД) не имеет в сигнатуре оператора create index возможности подставить после ON вместо имени таблицы ссылку на join двух или более таблиц, если только не создать предварительно материализованное представление и не сослаться на него. Но такой подход, очевидно, приведет к проблемам - материализованное представление нужно регулярно обновлять по запросу. И индекс по нему имеет смысл только для тех данных, которые в исходных таблицах обновляются исключительно редко. Иначе наш индекс по материализованному представлению будет выдавать регулярные ошибки поиска данных по индексу.

Вот если бы поля, по которым нужно создать составной индекс, находились в одной таблице, составной индекс можно создать без опаски. Однако, в моей схеме данных, эти поля в разных таблицах.

Но можно обойти данную проблему следующим образом. Обратите внимание, что у меня в таблице profile есть ссылки - внешние ключи и на id города, и на id пола. Поэтому вполне можно создать составной индекс не по названиям пола и города, а по их id - они в одной таблице. А запросы по названиям делать "в обход" - сначала получить из названий пола и города их id, а затем фильтром по обоим id найти пользователя. В данном случае будет три запроса, но каждый из них обращается к индексу, и в сумме они все равно отработают быстрее, чем если бы индексов не было.

Например, вот такой запрос:

```
select p.surname, s.name, c.name from users_scheme.profile p join users_scheme.sex s on p.sex_id = s.id join users_scheme.city c on p.city_id = c.id where s.name="male" and c.name="Moscow";
```

мы заменим вот таким запросом (это и будет его оптимизацией для использования составного индекса):

```
select p.surname, s.name, c.name from users_scheme.profile p join users_scheme.sex s on p.sex_id = s.id join users_scheme.city c on p.city_id = c.id where s.id=(select id from users_scheme.sex where name="male") and c.id=(select id from users.scheme.city where name="Moscow");
```
Для решения задачи создаем два индекса по названию пола и по названию города, и один индекс - составной по id пола + id города (отдельные независимые индексы по id пола и по id города, которые понадобятся во вложенных запросах в последнем примере запроса уже существуют, так как это первичные ключи, а индексы по первичным ключам создаются всегда автоматически). Отдельно отмечу, что везде я использовал тип индекса hash, потому что он работает быстрее, чем дефолтовый b-tree, а поиск у нас предполагается только по точному совпадению.

Используя схему нашей БД можно также составить еще много разных индексов или сочетаний (индекс + правильно составленный обходной запрос), которые оптимизируют работу нашей БД. Но это зависит на самом деле от приложения, которое будет использовать эту БД - нет смысла загромождать БД индексами, которые не будут использоваться, но будут замедлять работу БД при обновлениях и создании новых записей в таблицах. Поэтому ответ на вопрос - какие еще можно составить индексы, зависит больше не от схемы таблиц в БД, а от бизнес-логи приложения, и заранее ответить на этот вопрос нельзя.

