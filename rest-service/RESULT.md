Пойдем легким путем, подключим liquibase к проекту и настроим его на работу с БД (см. файлы проекта в коммите)

Далее, если бы мы использовали maven, ситуация была бы немного проще, можно было бы использовать liquibase-maven-plugin для генерации changeset из уже готовой БД, а именно этого я и добиваюсь, так как не хочется вручную писать его, уж очень много изменений было внесено уже в процессе выполнения предыдущих заданий.

Однако, аналогичный плагин liguibase-gradle-plugin показался мне более сложным в настройке, более года не обновлялся и на него много жалоб в Интернет на некорректную работу. Поэтому я пошел другим путем - установил локально из snap репозитория liquibase (в стандартных apt репозиториях ubuntu его нет). Затем сгенерировал changeset из готовой и наполненной БД такой командой:

![img.png](img.png)

для этого понадобилось указать напрямую путь к драйверу БД Postgresql, иначе будет ошибка генерации.

В итоге все получилось, changeset работоспособный:

![img_1.png](img_1.png)

Однако, есть недостаток такого подхода, но он не зависит от использования gradle или maven, та же самая проблема возникает у обоих. А именно - при использовании выделенной схемы БД (не дефолтовой) я не смог найти, чтобы liquibase умел бы самостоятельно создавать схему БД и назначать owner и grant для них https://docs.liquibase.com/change-types/home.html#data . Поэтому схему и пользователя все равно надо подготовить отдельно в БД до того, как заполнять пустую БД таблицами и данными внутри этой схемы. Возможно, что я смог бы этого добиться, используя change type sql в liquibase, который позволил бы выполнить любой sql код https://docs.liquibase.com/change-types/sql.html, но это уже за пределами данной задачи. Этой проблемы не возникло бы, если бы я использовал дефолтовую схему БД, как это обычно и делают для микросервисов сейчас (вообще, насколько я понял, теперь для микросервисной архитектуры вообще считается must have, чтобы каждый микросервис с отдельной задачей имел только ОДНУ БД для нее, поднятую в отдельном контейнере, поэтому нет смысла делать и отдельные схемы БД, которые нужны, только если БД многофункциональная и используется несколькими сервисами, что считается очень плохим)

Таким образом, цель работы, в принципе достигнута с небольшой оговоркой.