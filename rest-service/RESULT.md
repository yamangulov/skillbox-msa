Все три задачи 2.3, 2.4 и 2.10 взаимосвязаны и влияют друг на друга, поэтому лучше выполнять их в одной ветке одновременно.

Так как проект у меня вначале был развернут на github, первым делом задеплоим его вручную на gitlab в мой профиль, чтобы иметь возможность работать с пайплайнами gitlab:

https://gitlab.com/nairsharif/skillbox-msa

Затем устанавливаю sonarqube локально:

![img.png](img.png)

Настраиваю токены согласно инструкции, которая есть в самой админке сонара:

![img_1.png](img_1.png)

В том числе заполняю нужными токенами файл build.gradle
(рекомендую удалить токены оттуда для безопасности, но я их оставил просто потому, что запускал сонар в docker контейнере одноразовом, без сохранения его настроек, и больше его не собираюсь использовать, также использованные токены уничтожены и в gitlab)

Особо остановлюсь на файле [.gitlab-ci.yml](.gitlab-ci.yml) - в нем есть особенности, связанные с тем, что я собирал тестовые стенды локально на ноутбуке. Поэтому в gitlab я настроил и запустил gitlab-runner с экзекьютором shell(!), что позволило мне инсталлировать все мои стенды в kubernetes через helm. Кроме того, я обнаружил одну неприятную особенность инсталляции через helm именно для моей конфигурации кластера. Использование команды helm install приводит к тому, что невозможно установить чарт, который уже один раз проходил инсталляцию, так как gitlab ci/cd не удаляет автоматически созданные в неймспейсе поды по завершении пайплайна, если об этом специально не позаботиться. Кроме того - этого не может корректо выполнить и команда helm upgrade --install - потому что не удаляются созданные ingress хосты с именами, что не дает повторить команду и в такой форме. Поэтому я добавил отдельные стадии для очистки каждого стенда "в лоб" командой helm uninstall, которая удаляет все поды чарта, включая ingress вместе с хостами. Опция allow_failure: true добавлена в стадии очистки, чтобы они не прерывали пайплайн, если по какой-то причине нужный чарт уже был очищен (в этом случае стадия очистки падает с ошибкой)

Результат - все стадии прошли успешно (за исключением тех стадий очистки, где чарты были удалены, как и должно быть - там может быть успешное прохождение с ошибкой или без ошибки зависимо от предыстории работы с чартами):

![img_2.png](img_2.png)

Если бы я не разворачивал стенды локально в оболочке, а делал бы это через gitlab-runner с экзекьюторами kubernetes или docker в контейнерах, настройки пайплайнов существенно отличались бы и были бы сложнее. Но и мой способ оказался непростым. Поэтому, видимо, целесообразно не разворачивать стенды через gitlab ci/cd, а после прохождения всех проверок - тестов и сонар, - сохранять успешные артефакты в gitlab хранилище или куда-то еще, и потом разворачивать их оттуда. Однако, для модульных и интеграционных тестов установка стендов в пайплайне, возможно, будет полезной.

