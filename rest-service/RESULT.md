### 2.2

Для решения задачи выберем максимально экономный путь. Копируем файл [docker-compose.yml](docker_endpoint/docker-compose.yml) в каталог [.chart](.chart) и немного модифицируем его для работы с [Kompose](https://kubernetes.io/docs/tasks/configure-pod-container/translate-compose-kubernetes/#kompose-convert), для того, чтобы иметь возможность конвертировать его в чарт для Helm. (Придерживаемся принципа - если есть удобный инструмент для выполнения задачи - нужно пользоваться им, а не делать все вручную!). А именно - понижаем версию docker-compose.yml до 3.3 (так рекомендует документация, версии выше пока не поддерживаются) и добавляем labels, необходимые для настройки конвертации (см. итоговый файл [docker-compose.yml](.chart/docker-compose.yml)). А также добавляем секцию для сервиса rest-service с образом rest-service:0.0.1, который мы получаем из нашего приложения путем подключения к нему плагина jib:
![img_2.png](img_2.png)
и выполнения затем команды `gradle jibDockerBuild`, что также можно выполнить через Intellij Idea:
![img_3.png](img_3.png)
Затем выполняем конвертацию для Helm:
![img_1.png](img_1.png)
После этого удалим лишние незаполненные поля sources и home в файле [Chart.yml](.chart/docker-compose/Chart.yaml)

Выполним для проверки установку чарта в minikube:
![img_4.png](img_4.png)

Проверим состояние кластера:

![img_5.png](img_5.png)

Обратим внимание, что не все pod сразу могут перейти в состояние ready, например, приложение может стартовать слишком рано, пока БД еще не готова, через несколько минут это поправится.

Чтобы удобно было работать, настроим port forwarding в Intellij Idea и убедимся, что все таблицы создались и миграция в БД пролилась:

![img_6.png](img_6.png)

### 2.9

Так как эти задачи частично пересекаются, обе выполнены в одной ветке. Кроме того, в других задачах упоминается 5 неймспейсов, поэтому я решил создать их все, а не только два, чтобы быть готовым к следующим задачам.

Прежде всего создадим сами неймспейсы с помощью файла [namespace.yaml](.chart/namespaces.yaml)

![img_7.png](img_7.png)

Теперь для каждого неймспейса приготовим файлы values и общий файл values. В общем файле будут общие переменные .Values, а в частных файлах - переменные для отдельных неймспейсов. В файлах yaml заменим нужные значения подстановками переменных (см. файлы в проекте). Не забудем добавить в секции spec/rules/http поле host, так его там не было - kompose не сгенерировал его, потому что на тот момент у нас был только один хост без указания имени в исходном файле docker-compose.yaml.

После этого успешно устанавливаем наши артефакты в соответствующие неймспейсы. Обратим внимание, что стандартный вывод информации сразу после выполнения команды установки содержит ошибку - неправильно указан фактический неймспейс, куда произошла установка, как default, прямая проверка показывает, что артефакты установились на самом деле именно туда, куда нужно:

![img_8.png](img_8.png)

Аналогично получаем для второго заданного в задаче неймспейса:

![img_9.png](img_9.png)

